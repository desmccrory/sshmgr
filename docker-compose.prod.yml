# =============================================================================
# sshmgr Production Docker Compose with Traefik TLS
# =============================================================================
# Usage:
#   1. Copy .env.example to .env and configure all required values
#   2. Ensure DNS points to this server for your domains
#   3. Start: docker compose -f docker-compose.prod.yml up -d
#   4. View logs: docker compose -f docker-compose.prod.yml logs -f
# =============================================================================

services:
  # ---------------------------------------------------------------------------
  # Traefik Reverse Proxy (TLS termination + Let's Encrypt)
  # ---------------------------------------------------------------------------
  traefik:
    image: traefik:v3.0
    container_name: sshmgr-traefik
    command:
      # API and Dashboard
      - "--api.dashboard=true"
      - "--api.insecure=false"
      # Docker provider
      - "--providers.docker=true"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=sshmgr-network"
      # Entrypoints
      - "--entrypoints.web.address=:80"
      - "--entrypoints.websecure.address=:443"
      # HTTP to HTTPS redirect
      - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
      - "--entrypoints.web.http.redirections.entrypoint.scheme=https"
      # Let's Encrypt ACME
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL:?ACME_EMAIL is required}"
      - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
      # Uncomment for Let's Encrypt staging (testing - avoids rate limits)
      # - "--certificatesresolvers.letsencrypt.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory"
      # Logging
      - "--log.level=${TRAEFIK_LOG_LEVEL:-INFO}"
      - "--accesslog=true"
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "letsencrypt_data:/letsencrypt"
    labels:
      # Dashboard (optional - access via https://traefik.${DOMAIN}/dashboard/)
      - "traefik.enable=true"
      - "traefik.http.routers.dashboard.rule=Host(`traefik.${DOMAIN}`) && (PathPrefix(`/api`) || PathPrefix(`/dashboard`))"
      - "traefik.http.routers.dashboard.entrypoints=websecure"
      - "traefik.http.routers.dashboard.tls.certresolver=letsencrypt"
      - "traefik.http.routers.dashboard.service=api@internal"
      - "traefik.http.routers.dashboard.middlewares=dashboard-auth"
      # Basic auth for dashboard (generate with: htpasswd -nb admin password)
      - "traefik.http.middlewares.dashboard-auth.basicauth.users=${TRAEFIK_DASHBOARD_AUTH:-}"
    restart: unless-stopped
    networks:
      - sshmgr-network
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M
    # Logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    # Security
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # PostgreSQL Database
  # ---------------------------------------------------------------------------
  postgres:
    image: postgres:16-alpine
    container_name: sshmgr-postgres
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-sshmgr}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
      POSTGRES_DB: ${POSTGRES_DB:-sshmgr}
      # Performance tuning (adjust based on available RAM)
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-sshmgr}"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - sshmgr-network
    # No external port exposure - only accessible within Docker network
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    # Logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
    # Security
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # PostgreSQL Backup Service
  # ---------------------------------------------------------------------------
  postgres-backup:
    image: postgres:16-alpine
    container_name: sshmgr-postgres-backup
    environment:
      PGHOST: postgres
      PGUSER: ${POSTGRES_USER:-sshmgr}
      PGPASSWORD: ${POSTGRES_PASSWORD}
      PGDATABASE: ${POSTGRES_DB:-sshmgr}
      BACKUP_RETENTION_DAYS: ${BACKUP_RETENTION_DAYS:-7}
    volumes:
      - postgres_backups:/backups
    # Run backup daily at 2 AM (cron-like using entrypoint)
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        echo "Backup service started. Running daily at 2 AM."
        while true; do
          # Wait until 2 AM
          current_hour=$$(date +%H)
          if [ "$$current_hour" = "02" ]; then
            echo "[`date -Iseconds`] Starting backup..."
            backup_file="/backups/sshmgr_`date +%Y%m%d_%H%M%S`.sql.gz"
            if pg_dump | gzip > "$$backup_file"; then
              echo "[`date -Iseconds`] Backup completed: $$backup_file"
              # Cleanup old backups
              find /backups -name "sshmgr_*.sql.gz" -mtime +$${BACKUP_RETENTION_DAYS} -delete
              echo "[`date -Iseconds`] Cleaned up backups older than $${BACKUP_RETENTION_DAYS} days"
            else
              echo "[`date -Iseconds`] ERROR: Backup failed!"
            fi
            # Sleep 1 hour to avoid running multiple times at 2 AM
            sleep 3600
          else
            # Check every 30 minutes
            sleep 1800
          fi
        done
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - sshmgr-network
    deploy:
      resources:
        limits:
          cpus: '0.25'
          memory: 128M
        reservations:
          cpus: '0.05'
          memory: 32M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # Keycloak Identity Provider (with PostgreSQL backend)
  # ---------------------------------------------------------------------------
  keycloak:
    image: quay.io/keycloak/keycloak:23.0
    container_name: sshmgr-keycloak
    command: start
    environment:
      # Admin credentials
      KC_BOOTSTRAP_ADMIN_USERNAME: ${KEYCLOAK_ADMIN:-admin}
      KC_BOOTSTRAP_ADMIN_PASSWORD: ${KEYCLOAK_ADMIN_PASSWORD:?KEYCLOAK_ADMIN_PASSWORD is required}
      # Database
      KC_DB: postgres
      KC_DB_URL: jdbc:postgresql://postgres:5432/${POSTGRES_DB:-sshmgr}
      KC_DB_USERNAME: ${POSTGRES_USER:-sshmgr}
      KC_DB_PASSWORD: ${POSTGRES_PASSWORD}
      # Features
      KC_FEATURES: device-flow
      # Hostname and proxy settings
      KC_HOSTNAME: auth.${DOMAIN}
      KC_HOSTNAME_STRICT: "true"
      KC_PROXY_HEADERS: xforwarded
      KC_HTTP_ENABLED: "true"
      # Health
      KC_HEALTH_ENABLED: "true"
      # JVM memory settings
      JAVA_OPTS_APPEND: "-Xms256m -Xmx512m"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.keycloak.rule=Host(`auth.${DOMAIN}`)"
      - "traefik.http.routers.keycloak.entrypoints=websecure"
      - "traefik.http.routers.keycloak.tls.certresolver=letsencrypt"
      - "traefik.http.services.keycloak.loadbalancer.server.port=8080"
    depends_on:
      postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "exec 3<>/dev/tcp/127.0.0.1/9000 && echo -e 'GET /health/ready HTTP/1.1\\r\\nHost: localhost\\r\\n\\r\\n' >&3 && cat <&3 | grep -q '200 OK'"]
      interval: 10s
      timeout: 5s
      retries: 15
      start_period: 60s
    restart: unless-stopped
    networks:
      - sshmgr-network
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 768M
        reservations:
          cpus: '0.25'
          memory: 384M
    # Logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
    # Security
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # sshmgr API Server
  # ---------------------------------------------------------------------------
  api:
    build:
      context: .
      dockerfile: Dockerfile
    image: sshmgr:${SSHMGR_VERSION:-latest}
    container_name: sshmgr-api
    environment:
      # Database
      SSHMGR_DATABASE_URL: postgresql+asyncpg://${POSTGRES_USER:-sshmgr}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-sshmgr}
      # Encryption (REQUIRED)
      SSHMGR_MASTER_KEY: ${SSHMGR_MASTER_KEY:?SSHMGR_MASTER_KEY is required}
      # Keycloak (internal URL for JWT validation)
      SSHMGR_KEYCLOAK_URL: http://keycloak:8080
      SSHMGR_KEYCLOAK_REALM: ${SSHMGR_KEYCLOAK_REALM:-sshmgr}
      SSHMGR_KEYCLOAK_CLIENT_ID: ${SSHMGR_KEYCLOAK_CLIENT_ID:-sshmgr-api}
      SSHMGR_KEYCLOAK_CLIENT_SECRET: ${SSHMGR_KEYCLOAK_CLIENT_SECRET:-}
      # API
      SSHMGR_API_HOST: 0.0.0.0
      SSHMGR_API_PORT: 8000
      # CORS (allow requests from web clients)
      SSHMGR_CORS_ORIGINS: https://${DOMAIN},https://api.${DOMAIN},https://auth.${DOMAIN}
      # Logging
      SSHMGR_LOG_LEVEL: ${SSHMGR_LOG_LEVEL:-INFO}
      SSHMGR_LOG_FORMAT: json
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.sshmgr.rule=Host(`api.${DOMAIN}`)"
      - "traefik.http.routers.sshmgr.entrypoints=websecure"
      - "traefik.http.routers.sshmgr.tls.certresolver=letsencrypt"
      - "traefik.http.services.sshmgr.loadbalancer.server.port=8000"
      # Security headers
      - "traefik.http.middlewares.sshmgr-headers.headers.stsSeconds=31536000"
      - "traefik.http.middlewares.sshmgr-headers.headers.stsIncludeSubdomains=true"
      - "traefik.http.middlewares.sshmgr-headers.headers.contentTypeNosniff=true"
      - "traefik.http.middlewares.sshmgr-headers.headers.frameDeny=true"
      - "traefik.http.routers.sshmgr.middlewares=sshmgr-headers"
    depends_on:
      postgres:
        condition: service_healthy
      keycloak:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python", "-c", "import httpx; httpx.get('http://localhost:8000/api/v1/health').raise_for_status()"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
    restart: unless-stopped
    networks:
      - sshmgr-network
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M
    # Logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "5"
    # Security
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # sshmgr Frontend (Next.js)
  # ---------------------------------------------------------------------------
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        # Build-time variables (baked into the client bundle)
        NEXT_PUBLIC_API_URL: https://api.${DOMAIN}
    image: sshmgr-frontend:${SSHMGR_VERSION:-latest}
    container_name: sshmgr-frontend
    environment:
      # Auth.js configuration
      AUTH_SECRET: ${AUTH_SECRET:?AUTH_SECRET is required for frontend}
      AUTH_URL: https://${DOMAIN}
      AUTH_TRUST_HOST: "true"
      # Keycloak (external URL - used for browser redirects)
      KEYCLOAK_URL: https://auth.${DOMAIN}
      KEYCLOAK_REALM: ${SSHMGR_KEYCLOAK_REALM:-sshmgr}
      KEYCLOAK_CLIENT_ID: ${KEYCLOAK_WEB_CLIENT_ID:-sshmgr-web}
      KEYCLOAK_CLIENT_SECRET: ${KEYCLOAK_WEB_CLIENT_SECRET:?KEYCLOAK_WEB_CLIENT_SECRET is required}
      # API URL (internal for server-side requests)
      NEXT_PUBLIC_API_URL: https://api.${DOMAIN}
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.frontend.rule=Host(`${DOMAIN}`)"
      - "traefik.http.routers.frontend.entrypoints=websecure"
      - "traefik.http.routers.frontend.tls.certresolver=letsencrypt"
      - "traefik.http.services.frontend.loadbalancer.server.port=3000"
      # Security headers
      - "traefik.http.middlewares.frontend-headers.headers.stsSeconds=31536000"
      - "traefik.http.middlewares.frontend-headers.headers.stsIncludeSubdomains=true"
      - "traefik.http.middlewares.frontend-headers.headers.contentTypeNosniff=true"
      - "traefik.http.middlewares.frontend-headers.headers.frameDeny=true"
      - "traefik.http.routers.frontend.middlewares=frontend-headers"
    depends_on:
      api:
        condition: service_healthy
      keycloak:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "wget", "--no-verbose", "--tries=1", "--spider", "http://localhost:3000/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s
    restart: unless-stopped
    networks:
      - sshmgr-network
    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 128M
    # Logging with rotation
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    # Security
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # Prometheus (Metrics Collection)
  # ---------------------------------------------------------------------------
  prometheus:
    image: prom/prometheus:v2.48.0
    container_name: sshmgr-prometheus
    profiles:
      - monitoring
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=${PROMETHEUS_RETENTION:-15d}'
      - '--web.enable-lifecycle'
      - '--web.enable-admin-api'
    volumes:
      - ./monitoring/prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - ./monitoring/prometheus/alerts.yml:/etc/prometheus/alerts.yml:ro
      - prometheus_data:/prometheus
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.prometheus.rule=Host(`prometheus.${DOMAIN}`)"
      - "traefik.http.routers.prometheus.entrypoints=websecure"
      - "traefik.http.routers.prometheus.tls.certresolver=letsencrypt"
      - "traefik.http.services.prometheus.loadbalancer.server.port=9090"
      - "traefik.http.routers.prometheus.middlewares=prometheus-auth"
      - "traefik.http.middlewares.prometheus-auth.basicauth.users=${MONITORING_BASIC_AUTH:-}"
    depends_on:
      - api
    restart: unless-stopped
    networks:
      - sshmgr-network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
        reservations:
          cpus: '0.1'
          memory: 128M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # AlertManager (Alert Routing and Notifications)
  # ---------------------------------------------------------------------------
  alertmanager:
    image: prom/alertmanager:v0.26.0
    container_name: sshmgr-alertmanager
    profiles:
      - monitoring
    command:
      - '--config.file=/etc/alertmanager/alertmanager.yml'
      - '--storage.path=/alertmanager'
      - '--cluster.listen-address='
    volumes:
      - ./monitoring/alertmanager/alertmanager.yml:/etc/alertmanager/alertmanager.yml:ro
      - alertmanager_data:/alertmanager
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.alertmanager.rule=Host(`alertmanager.${DOMAIN}`)"
      - "traefik.http.routers.alertmanager.entrypoints=websecure"
      - "traefik.http.routers.alertmanager.tls.certresolver=letsencrypt"
      - "traefik.http.services.alertmanager.loadbalancer.server.port=9093"
      - "traefik.http.routers.alertmanager.middlewares=alertmanager-auth"
      - "traefik.http.middlewares.alertmanager-auth.basicauth.users=${MONITORING_BASIC_AUTH:-}"
    restart: unless-stopped
    networks:
      - sshmgr-network
    deploy:
      resources:
        limits:
          cpus: '0.25'
          memory: 128M
        reservations:
          cpus: '0.05'
          memory: 32M
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "2"
    security_opt:
      - no-new-privileges:true

  # ---------------------------------------------------------------------------
  # Grafana (Dashboards and Visualization)
  # ---------------------------------------------------------------------------
  grafana:
    image: grafana/grafana:10.2.2
    container_name: sshmgr-grafana
    profiles:
      - monitoring
    environment:
      GF_SECURITY_ADMIN_USER: ${GRAFANA_ADMIN_USER:-admin}
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_ADMIN_PASSWORD:?GRAFANA_ADMIN_PASSWORD is required when using monitoring profile}
      GF_USERS_ALLOW_SIGN_UP: "false"
      GF_SERVER_ROOT_URL: https://grafana.${DOMAIN}
      GF_INSTALL_PLUGINS: grafana-piechart-panel
      # Anonymous access (read-only dashboards) - optional
      GF_AUTH_ANONYMOUS_ENABLED: ${GRAFANA_ANONYMOUS_ENABLED:-false}
      GF_AUTH_ANONYMOUS_ORG_ROLE: Viewer
    volumes:
      - ./monitoring/grafana/provisioning:/etc/grafana/provisioning:ro
      - grafana_data:/var/lib/grafana
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.grafana.rule=Host(`grafana.${DOMAIN}`)"
      - "traefik.http.routers.grafana.entrypoints=websecure"
      - "traefik.http.routers.grafana.tls.certresolver=letsencrypt"
      - "traefik.http.services.grafana.loadbalancer.server.port=3000"
    depends_on:
      - prometheus
    restart: unless-stopped
    networks:
      - sshmgr-network
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
    security_opt:
      - no-new-privileges:true

volumes:
  postgres_data:
    driver: local
  postgres_backups:
    driver: local
  letsencrypt_data:
    driver: local
  prometheus_data:
    driver: local
  alertmanager_data:
    driver: local
  grafana_data:
    driver: local

networks:
  sshmgr-network:
    name: sshmgr-network
    driver: bridge
